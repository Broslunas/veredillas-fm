---
// src/components/MiniPlayer.astro
// Persisted player component that listens for 'play-episode' events
// Now with PROFESSIONAL UI Upgrade
import FloatingBar from './player/FloatingBar.astro';
import ImmersiveView from './player/ImmersiveView.astro';
import './player/SharedPlayerStyles.css';
---

<!-- Template for the Custom Player (Cloned by JS) -->
<template id="custom-player-template">
  <div class="custom-audio-player">
      <div class="player-card" id="customPlayerCard">
         <!-- Dynamic ambient glow behind -->
         <div class="player-bg-glow" id="playerBgGlow"></div>

         <div class="player-grid">
            <!-- TOP: Metadata (Title Row) -->
            <div class="track-details">
                <h2 class="track-title" id="playerTitle">Título del Episodio</h2>
                <p class="track-artist" id="playerAuthor">Veredillas FM</p>
            </div>

            <!-- LEFT: Artwork -->
            <div class="player-artwork">
                <div class="artwork-wrapper">
                    <img src="" alt="" class="player-cover-img" id="playerCoverImg" />
                    <div class="artwork-placeholder hidden" id="playerCoverPlaceholder">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle></svg>
                    </div>
                </div>
            </div>

            <!-- CENTER: Body -->
            <div class="player-body">
                <div class="mini-visualizer">
                    <canvas id="audioVisualizer" width="300" height="64"></canvas>
                </div>

                <div class="player-controls-container">
                    <!-- Progress Bar -->
                     <div class="player-progress">
                        <span class="time-text" id="currentTime">00:00</span>
                        <div class="seek-slider-wrapper" id="seekWrapper">
                            <div class="seek-track-bg">
                                <div class="seek-track-fill" id="seekFill"></div>
                            </div>
                            <!-- Actual input for dragging -->
                            <input type="range" class="u-hidden-range" id="seekBar" value="0" step="0.1" />
                        </div>
                        <span class="time-text" id="totalTime">00:00</span>
                     </div>
                    
                    <!-- Main Buttons -->
                    <div class="item-controls">
                        <button class="btn-ctrl secondary-hide" id="backwardBtn" aria-label="Retroceder 15s">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 17l-5-5 5-5M18 17l-5-5 5-5"/></svg>
                        </button>
                        
                        <button class="btn-ctrl primary-play" id="playPauseBtn" aria-label="Reproducir/Pausar">
                            <svg id="iconPlay" class="icon-play" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
                            <svg id="iconPause" class="hidden" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
                            <svg id="iconLoading" class="hidden spinner" viewBox="0 0 50 50"><circle class="path" cx="25" cy="25" r="20" fill="none" stroke-width="5"></circle></svg>
                        </button>
                        
                        <button class="btn-ctrl secondary-hide" id="forwardBtn" aria-label="Avanzar 15s">
                             <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 17l5-5-5-5M6 17l5-5-5-5"/></svg>
                        </button>
                    </div>
                </div>
            </div>

            <!-- RIGHT: Extras -->
            <div class="player-extras">
                <button class="speed-toggle" id="speedBtn" title="Velocidad">1x</button>
                <div class="volume-area">
                    <button class="btn-ctrl" style="padding:4px; pointer-events:none;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
                    </button>
                    <input type="range" class="volume-slider" id="volumeBar" min="0" max="1" step="0.05" value="1" />
                </div>
                <button class="btn-ctrl" id="maximizeBtn" aria-label="Pantalla completa">
                     <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7"/></svg>
                </button>
            </div>
         </div>
      </div>
      <!-- Core Audio Element -->
      <audio id="audioElement" preload="metadata" crossorigin="anonymous"></audio>
  </div>
</template>


<!-- Mini Player (Floating) Layout Components -->
<FloatingBar />
<ImmersiveView />

<!-- Controller Logic -->
<script>
    import { FastAverageColor } from 'fast-average-color';
    // @ts-ignore

    declare global {
        interface Window {
            hasGlobalPlayerListener: boolean;
            playerCurrentUrl: string | null;
            playerMeta: { title: string, image: string, author: string } | null;
            playerSlug: string | null;
            visualizerInterval: number;
        }
    }

    if (!window.playerCurrentUrl) {
         window.playerCurrentUrl = null;
         window.playerMeta = null;
         window.playerSlug = null;
    }
        
    const fac = new FastAverageColor();

    // ---- Ambient Mode Logic ----
    const updateAmbientTheme = async (imageUrl: string) => {
        try {
            const color = await fac.getColorAsync(imageUrl);
            // Update global vars for immersive
            document.documentElement.style.setProperty('--color-primary-glow', color.rgba);
            
            // Also update the local inline player glow if present
            const localGlow = document.getElementById('playerBgGlow');
            if(localGlow) {
                // Use a mix for better visual
                localGlow.style.background = `radial-gradient(circle at center, ${color.rgba}, transparent 70%)`;
            }

            // Update immersive glow
            const glow = document.querySelector('.background-glow') as HTMLElement;
            if (glow) {
                glow.style.background = `radial-gradient(circle at center, ${color.rgba}, transparent 70%)`;
            }
        } catch (e) {
            console.log("Ambient color check failed", e);
        }
    };

    const setupCustomPlayer = (container: HTMLElement, url: string, title: string, cover: string, author: string, transcription: any[] | null = null, startTime: number = 0, isPremiere: boolean = false, premiereDate: number = 0) => {
             // 1. CLONE TEMPLATE
             container.innerHTML = '';
             const template = document.getElementById('custom-player-template') as HTMLTemplateElement;
             if (!template) {
                 console.error("Player Template not found!");
                 return;
             }
             
             const clone = template.content.cloneNode(true) as DocumentFragment;
             container.appendChild(clone);
             
             // 2. Populate Data
             const audioElement = container.querySelector('#audioElement') as HTMLAudioElement;
             audioElement.src = url;
             
             if (startTime > 0) {
                 audioElement.currentTime = startTime;
             }

             // Metadata
             const titleEl = container.querySelector('#playerTitle');
             const authorEl = container.querySelector('#playerAuthor');
             const imgEl = container.querySelector('#playerCoverImg') as HTMLImageElement;
             const placeholderEl = container.querySelector('#playerCoverPlaceholder');
             
             if(titleEl) titleEl.textContent = title;
             if(authorEl) authorEl.textContent = author;
             
             if (cover) {
                 if(imgEl) {
                     imgEl.src = cover;
                     imgEl.classList.remove('hidden');
                 }
                 if(placeholderEl) placeholderEl.classList.add('hidden');
             } else {
                 if(imgEl) imgEl.classList.add('hidden');
                 if(placeholderEl) placeholderEl.classList.remove('hidden');
             }

             // 3. Attach Logic
             const playBtn = container.querySelector('#playPauseBtn') as HTMLElement;
             const backBtn = container.querySelector('#backwardBtn') as HTMLElement;
             const fwdBtn = container.querySelector('#forwardBtn') as HTMLElement;
             const seekBar = container.querySelector('#seekBar') as HTMLInputElement;
             const seekFill = container.querySelector('#seekFill') as HTMLElement;
             
             const volumeBar = container.querySelector('#volumeBar') as HTMLInputElement;
             const speedBtn = container.querySelector('#speedBtn') as HTMLElement;
             
             const currTimeEl = container.querySelector('#currentTime');
             const totTimeEl = container.querySelector('#totalTime');

             const iconPlay = container.querySelector('#iconPlay');
             const iconPause = container.querySelector('#iconPause');
             const iconLoading = container.querySelector('#iconLoading');
             
             const speeds = [1, 1.25, 1.5, 2, 0.75];
             let speedIdx = 0;

             // --- PREMIERE RESTRICTION HELPER ---
             const getMaxSeekTime = () => {
                 if (!isPremiere || !premiereDate) return Infinity;
                 const now = Date.now();
                 // Seconds since premiere started
                 return (now - premiereDate) / 1000;
             };

             // State updates
             const updateIcons = () => {
                 if(iconLoading && !iconLoading.classList.contains('hidden')) return;
                 if(audioElement.paused) {
                     iconPlay?.classList.remove('hidden');
                     iconPause?.classList.add('hidden');
                 } else {
                     iconPlay?.classList.add('hidden');
                     iconPause?.classList.remove('hidden');
                 }
             };

             const formatTime = (s: number) => {
                 const m = Math.floor(s / 60);
                 const sec = Math.floor(s % 60);
                 return `${m}:${sec < 10 ? '0'+sec : sec}`;
             };

             // Listeners
             playBtn.onclick = () => {
                 if(audioElement.paused) audioElement.play();
                 else audioElement.pause();
             };
             
             backBtn.onclick = () => audioElement.currentTime = Math.max(0, audioElement.currentTime - 15);
             
             fwdBtn.onclick = () => {
                 const max = getMaxSeekTime();
                 const current = audioElement.currentTime;
                 const target = current + 15;
                 
                 // Limit forward seek if premiere
                 if (target > max) {
                     // Can't go future
                     return; 
                 }
                 audioElement.currentTime = Math.min(audioElement.duration, target);
             };
             
             // Seek Bar Logic
             const updateSeekUI = () => {
                 const percent = (audioElement.currentTime / audioElement.duration) * 100;
                 if(!isNaN(percent) && seekFill) seekFill.style.width = `${percent}%`;
                 if(currTimeEl) currTimeEl.textContent = formatTime(audioElement.currentTime);
                 
                 // Visual indication of "Live" limit?
                 // Could limit the slider width visually, but `max` attribute on range input is better
                 // but range input is 0-duration. 
             };

             seekBar.oninput = () => {
                 let val = parseFloat(seekBar.value);
                 
                 // RESTRICTION CHECK
                 const max = getMaxSeekTime();
                 if (val > max) {
                     val = max;
                 }
                 
                 audioElement.currentTime = val;
                 updateSeekUI();
             }
             
             // --- AUTO-PLAY FOR PREMIERE ---
             if (isPremiere) {
                 // Try to play immediately
                 // Note: Browsers might block if no interaction, but since user likely clicked "Enter" or we reloaded, 
                 // we might need interaction. On reload? tough.
                 // But most "Live" pages attempt it.
                 // We can mute initially? No, podcast.
                 // Let's try.
                 audioElement.play().catch(e => {
                     console.log("Premiere auto-play blocked", e);
                     // Show a big "Play" overlay?
                     // For now, rely on user clicking global play.
                 });
             }
             
             let lastTrackedTime = audioElement.currentTime;
             let sessionAccumulator = 0;
             const SESSION_SYNC_THRESHOLD = 10; 

             const syncListeningTime = async (seconds: number) => {
                 if (seconds <= 0.1) return; // Ignore neg or tiny
                 try {
                     // Fire and forget, don't await blocking UI
                     fetch('/api/user/stats', {
                         method: 'POST',
                         headers: { 'Content-Type': 'application/json' },
                         body: JSON.stringify({ increment: seconds })
                     });
                 } catch(e) {
                     console.error("Stats sync error", e);
                 }
             };

              // SYNC PLAYBACK HISTORY
              const syncPlaybackHistory = async (slug: string, currentTime: number, duration: number, completed: boolean = false) => {
                   if(!slug) return;
                   
                   try {
                       fetch('/api/history/update', {
                           method: 'POST',
                           credentials: 'include', // Ensure cookies are sent (localhost/cors safety)
                           headers: { 'Content-Type': 'application/json' },
                           body: JSON.stringify({ 
                               episodeSlug: slug,
                               progress: currentTime,
                               duration: isFinite(duration) ? duration : 0,
                               completed
                           })
                       });
                   } catch(e) {
                       console.error("History sync error", e);
                   }
              };

              const updateSeek = () => {
                   const current = audioElement.currentTime;
                   
                   // Tracking Logic
                   const delta = current - lastTrackedTime;
                   // Only count if playing normal speed (approx) and not seeking (large jumps)
                   if (delta > 0 && delta < 5 && !audioElement.paused) {
                       sessionAccumulator += delta;
                       if(sessionAccumulator >= SESSION_SYNC_THRESHOLD) {
                           syncListeningTime(sessionAccumulator);
                           // Sync history every 10s as well
                           if(window.playerSlug) syncPlaybackHistory(window.playerSlug, current, audioElement.duration);
                           sessionAccumulator = 0;
                       }
                   }
                   lastTrackedTime = current;
                   
                   if(document.activeElement !== seekBar) {
                       seekBar.value = current.toString();
                       updateSeekUI();
                   }
                   
                   // Dispatch Global Event for Widgets
                   document.dispatchEvent(new CustomEvent('veredillas:audio-timeupdate', {
                       detail: { currentTime: current, duration: audioElement.duration }
                   }));
              };

             volumeBar.oninput = () => {
                 audioElement.volume = parseFloat(volumeBar.value);
             }
             
             speedBtn.onclick = () => {
                 speedIdx = (speedIdx + 1) % speeds.length;
                 const s = speeds[speedIdx];
                 audioElement.playbackRate = s;
                 speedBtn.innerText = `${s}x`;
             }

             // Maximize
             const maxBtn = container.querySelector('#maximizeBtn') as HTMLElement;
             if(maxBtn) {
                 maxBtn.onclick = () => {
                     const immersive = document.getElementById('immersive-player');
                     if (immersive) immersive.classList.remove('hidden');
                 };
             }

             // Audio events
             audioElement.ontimeupdate = updateSeek;
             
             audioElement.onloadedmetadata = () => {
                 seekBar.max = audioElement.duration.toString();
                 if(totTimeEl) totTimeEl.textContent = formatTime(audioElement.duration);
                 iconLoading?.classList.add('hidden');
                 updateIcons();
             };
             
             audioElement.onwaiting = () => {
                 iconPlay?.classList.add('hidden');
                 iconPause?.classList.add('hidden');
                 iconLoading?.classList.remove('hidden');
             };
             
             audioElement.onplaying = () => {
                 iconLoading?.classList.add('hidden');
                 updateIcons();
                 initVisualizer(); 
             };
             
             audioElement.onplay = () => {
                 lastTrackedTime = audioElement.currentTime; // Reset tracking base
                 updateIcons();
             };
             audioElement.onpause = () => {
                 updateIcons();
                 // Flush pending time
                 if(sessionAccumulator > 0.5) {
                     syncListeningTime(sessionAccumulator);
                     sessionAccumulator = 0;
                 }
                 // Flush history on pause
                 if(window.playerSlug) syncPlaybackHistory(window.playerSlug, audioElement.currentTime, audioElement.duration);
             };
             
             // Error Handling 
             audioElement.onerror = (e) => {
                 const error = audioElement.error;
                 if (error && (error.code === MediaError.MEDIA_ERR_NETWORK || error.code === MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED)) {
                     if (audioElement.hasAttribute("crossorigin")) {
                         audioElement.removeAttribute("crossorigin");
                         audioElement.load();
                         // NO AUTOPLAY ON ERROR RECOVERY
                     }
                 }
             };

             audioElement.onended = () => {
                 if(window.playerSlug) syncPlaybackHistory(window.playerSlug, audioElement.duration, audioElement.duration, true);
             };
             
             // Visualizer
             let audioCtx: AudioContext;
             let analyser: AnalyserNode;
             let source: MediaElementAudioSourceNode;
             let canvas = container.querySelector('#audioVisualizer') as HTMLCanvasElement;
             
             const initVisualizer = () => {
                 if (!audioElement.crossOrigin) return; 

                 if(!audioCtx) {
                      const AudioContext = window.AudioContext || (window as any).webkitAudioContext;
                      audioCtx = new AudioContext();
                      try {
                          source = audioCtx.createMediaElementSource(audioElement);
                          analyser = audioCtx.createAnalyser();
                          analyser.fftSize = 256; // Higher res
                          source.connect(analyser);
                          analyser.connect(audioCtx.destination);
                          draw();
                      } catch(e) {
                          console.log("Audio Context Error (CORS?):", e);
                      }
                 } else if (audioCtx.state === 'suspended') {
                     audioCtx.resume();
                 }
             };
             
             const draw = () => {
                 if(!canvas || !analyser) return;
                 const ctx = canvas.getContext('2d');
                 if(!ctx) return;
                 const bufferLength = analyser.frequencyBinCount;
                 const dataArray = new Uint8Array(bufferLength);
                 
                 const renderFrame = () => {
                     if(audioElement.paused) return; 
                     requestAnimationFrame(renderFrame);
                     ctx.clearRect(0,0, canvas.width, canvas.height);
                     
                     analyser.getByteFrequencyData(dataArray);

                     // Smooth visuals
                     const bars = 40;
                     const step = Math.ceil(bufferLength / bars);
                     const w = canvas.width / bars;
                     
                     ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                     
                     for(let i=0; i<bars; i++) {
                         let sum = 0;
                         for(let j=0; j<step; j++) {
                             if(dataArray[i*step + j]) sum += dataArray[i*step + j];
                         }
                         let val = sum / step;
                         const h = (val / 255) * canvas.height;
                         
                         // Rounded bars?
                         const x = i * w;
                         const y = canvas.height - h;
                         
                         // Gradient
                         // ctx.fillRect(x, y, w - 2, h);
                         
                         // Let's do rounded top
                         if(h > 0) {
                             ctx.beginPath();
                             ctx.roundRect(x, y, w - 3, h, [4, 4, 0, 0]);
                             ctx.fill();
                         }
                     }
                     
                     // Also handle Immersive Visualizer (Global)
                     // [Logic copied/simplified from previous version...]
                     const immCanvas = document.getElementById('audio-visualizer') as HTMLCanvasElement;
                     if(immCanvas && document.getElementById('immersive-player')?.classList.contains('active')) {
                         // ... (keep immersive visualizer logic if needed or reimplement)
                     }
                 };
                 renderFrame();
             };

             // Initial Ambient
             if(cover) updateAmbientTheme(cover);

             // --- Initialize Immersive Sync (Metadata) ---
             const immTitle = document.getElementById('immersive-title');
             const immAuthor = document.getElementById('immersive-author');
             const immCover = document.getElementById('immersive-cover') as HTMLImageElement;
             
             if(immTitle) immTitle.innerText = title;
             if(immAuthor) immAuthor.innerText = author;
             if(immCover) immCover.src = cover || '/logo.png';
             
             // Setup Seek Sync with Immersive
             setupImmersiveSync(audioElement, {
                title, author, cover, transcription
             });
    };

    // Helper for Immersive Sync (Metadata & Transcription)
    const setupImmersiveSync = (audio: HTMLAudioElement, meta: any) => {
             const immPlayBtn = document.getElementById('imm-play-btn');
             const immIconPlay = document.getElementById('imm-icon-play');
             const immIconPause = document.getElementById('imm-icon-pause');
             const immSeekBar = document.getElementById('imm-seek-bar') as HTMLInputElement;
             const immCurrentTime = document.getElementById('imm-current-time');
             const immDuration = document.getElementById('imm-duration');
             const immBack = document.getElementById('imm-back-btn');
             const immFwd = document.getElementById('imm-fwd-btn');

             const collapseBtn = document.getElementById('collapse-player');
             

             
             // Collapse Player
             if (collapseBtn) {
                 collapseBtn.onclick = () => {
                     document.getElementById('immersive-player')?.classList.add('hidden');
                 };
             }

             if(immPlayBtn) {
                 immPlayBtn.onclick = () => {
                     if(audio.paused) audio.play();
                     else audio.pause();
                 };
             }
             if(immBack) immBack.onclick = () => audio.currentTime = Math.max(0, audio.currentTime - 15);
             if(immFwd) immFwd.onclick = () => audio.currentTime = Math.min(audio.duration, audio.currentTime + 15);
             
             if(immSeekBar) {
                 immSeekBar.oninput = () => audio.currentTime = parseFloat(immSeekBar.value);
             }



             // Time Update Sync
             const onTimeUpdate = () => {
                 if(immSeekBar && document.activeElement !== immSeekBar) immSeekBar.value = audio.currentTime.toString();
                 if(immCurrentTime) {
                      const m = Math.floor(audio.currentTime / 60);
                      const s = Math.floor(audio.currentTime % 60);
                      immCurrentTime.textContent = `${m}:${s < 10 ? '0'+s : s}`;
                 }
                 

             };
             
             audio.addEventListener('timeupdate', onTimeUpdate);
             
             audio.addEventListener('play', () => {
                  if(immIconPlay) immIconPlay.classList.add('hidden');
                  if(immIconPause) immIconPause.classList.remove('hidden');
             });
             audio.addEventListener('pause', () => {
                  if(immIconPlay) immIconPlay.classList.remove('hidden');
                  if(immIconPause) immIconPause.classList.add('hidden');
             });
             
             audio.addEventListener('loadedmetadata', () => {
                 if(immSeekBar) immSeekBar.max = audio.duration.toString();
                 if(immDuration) {
                      const m = Math.floor(audio.duration / 60);
                      const s = Math.floor(audio.duration % 60);
                      immDuration.textContent = `${m}:${s < 10 ? '0'+s : s}`;
                 }
             });
    };

    // Global State Update
    const updatePlayerState = () => {
            const player = document.getElementById('mini-player');
            const placeholder = document.getElementById('episode-player-placeholder');
            const container = document.getElementById('player-placeholder');
            
            if (!player || !container) return;

            if (placeholder) {
                // Determine if we should render yet (might be hidden by countdown)
                const parentWrapper = document.getElementById('premiere-player-wrapper');
                const isHiddenPremiere = parentWrapper && (window.getComputedStyle(parentWrapper).display === 'none' || parentWrapper.classList.contains('hidden'));
                
                if (isHiddenPremiere) {
                    // Don't render inline player yet if it is waiting for premiere
                    // Ensure player is hidden so it doesn't stick around from previous state or default
                    player.classList.add('hidden');
                    return; 
                }

                // INLINE MODE
                const spotifyUrl = placeholder.getAttribute('data-spotify-url');
                const audioUrl = placeholder.getAttribute('data-audio-url');
                const url = spotifyUrl || audioUrl;
                const title = placeholder.getAttribute('data-title');
                const image = placeholder.getAttribute('data-image');
                const author = placeholder.getAttribute('data-author');
                const slug = placeholder.getAttribute('data-slug');

                if (title) {
                    window.playerMeta = { title, image: image || '/logo.png', author: author || 'Veredillas FM' };
                    if(slug) window.playerSlug = slug;
                }

                // Conflict Check
                if (window.playerCurrentUrl && url && window.playerCurrentUrl !== url) {
                    // Conflict -> Show Floating
                    if (container.hasChildNodes()) {
                        player.classList.remove('inline', 'hidden');
                        player.classList.add('floating', 'visible');
                        
                        // Apply floating specific styles just in case JS needs to force it, though CSS handles .floating
                        document.body.style.paddingBottom = '100px';
                    }
                    
                    // Render "Currently Playing different ep" prompt in placeholder
                    if (!placeholder.hasAttribute('data-rendered-prompt')) {
                         placeholder.setAttribute('data-rendered-prompt', 'true');
                         placeholder.innerHTML = `
                            <div class="glass-panel" style="width:100%; height:160px; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:16px; border-radius:12px;">
                                <p style="margin:0; color: #a1a1aa;">Estás escuchando otro episodio</p>
                                <button id="force-play-btn" class="btn btn-primary" style="font-size:0.9rem; padding: 6px 16px;">
                                    Reproducir este
                                </button>
                            </div>
                        `;
                        placeholder.querySelector('#force-play-btn')?.addEventListener('click', () => {
                             window.playerCurrentUrl = null; 
                             container.innerHTML = ''; // Reset floating player
                             updatePlayerState(); // Re-run to trigger inline setup
                        });
                    }
                    return;
                }

                // Setup Inline
                if (url && window.playerCurrentUrl !== url) {
                    window.playerCurrentUrl = url;
                    
                    if (spotifyUrl) {
                        // Spotify Logic
                        let finalUrl = url;
                        try {
                             const urlObj = new URL(url);
                             if (!urlObj.pathname.includes('/embed/')) {
                                  const segments = urlObj.pathname.split('/').filter(Boolean);
                                  if (segments[0] !== 'embed') finalUrl = `${urlObj.origin}/embed${urlObj.pathname}`;
                             }
                        } catch(e) {}
                        
                        container.innerHTML = `<iframe style="border-radius:12px" src="${finalUrl}" width="100%" height="152" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" loading="lazy"></iframe>`;
                        
                    } else if (audioUrl && title) {
                        const transcriptionStr = placeholder.getAttribute('data-transcription');
                        const startStr = placeholder.getAttribute('data-start-time');
                        const startTime = startStr ? parseFloat(startStr) : 0;
                        
                        // PREMIERE LOGIC READ
                        const isPremiere = placeholder.getAttribute('data-is-premiere') === 'true';
                        const premiereDateStr = placeholder.getAttribute('data-premiere-date');
                        const premiereDate = premiereDateStr ? new Date(premiereDateStr).getTime() : 0;

                        const trans = transcriptionStr ? JSON.parse(transcriptionStr) : null;
                        setupCustomPlayer(container, audioUrl, title, image || '', author || '', trans, startTime, isPremiere, premiereDate);
                    }
                }

                // Move Player to Placeholder
                const rect = placeholder.getBoundingClientRect();
                const scrollY = window.scrollY || window.pageYOffset;
                const scrollX = window.scrollX || window.pageXOffset;

                player.classList.remove('floating', 'hidden');
                player.classList.add('inline', 'visible');
                
                player.style.position = 'absolute';
                player.style.top = `${rect.top + scrollY}px`;
                player.style.left = `${rect.left + scrollX}px`;
                player.style.width = `${rect.width}px`;
                player.style.height = 'auto'; // Content-driven height
                
                // Force wrapper to auto
                const wrapper = player.querySelector('.player-wrapper') as HTMLElement;
                if(wrapper) {
                    wrapper.style.height = 'auto';
                    wrapper.style.minHeight = '100%';
                }
                
                // Sync Placeholder Height to match Player Content
                // We use requestAnimationFrame to ensure render
                requestAnimationFrame(() => {
                    if (player.offsetHeight > 0) {
                        placeholder.style.height = `${player.offsetHeight}px`;
                    }
                });

                document.body.style.paddingBottom = '0';

            } else {
                // FLOATING MODE
                if (container.hasChildNodes()) {
                    player.classList.remove('inline', 'hidden');
                    player.classList.add('floating', 'visible');

                    player.style.position = 'fixed';
                    player.style.top = 'auto'; // Reset
                    player.style.bottom = '0';
                    player.style.left = '0';
                    player.style.width = '100%';
                    player.style.height = 'auto';

                    document.body.style.paddingBottom = '100px';
                } else {
                    player.classList.add('hidden');
                    document.body.style.paddingBottom = '0';
                }
            }
    };

    // Event Listeners
    window.addEventListener('resize', updatePlayerState);
    document.addEventListener('DOMContentLoaded', updatePlayerState);
    
    // Play Episode Event
    document.addEventListener('play-episode', ((e: Event) => {
         const customEvent = e as CustomEvent;
          const { url, title, image, author } = customEvent.detail;
          const slug = customEvent.detail.slug; // Passed dynamically?
          // If we played from a card that didn't pass slug, we might miss it.
          // But EpisodeCard usually navigates. 
          // If we play from Play Button on card, we need slug.
          
          const container = document.getElementById('player-placeholder');
          if(container) {
              window.playerCurrentUrl = url;
              window.playerMeta = { title, image, author };
              if(slug) window.playerSlug = slug;
              
              setupCustomPlayer(container, url, title, image, author);
             updatePlayerState();
             
             // FORCE PLAY
             const audio = container.querySelector('audio') as HTMLAudioElement;
             if(audio) {
                 audio.play().catch(e => console.error("Auto-play failed:", e));
             }
         }
    }));

    // Close Button Logic (in FloatingBar)
    document.addEventListener('click', (e) => {
       const target = e.target as HTMLElement;
       if(target.closest('#close-player')) {
           const player = document.getElementById('mini-player');
           const container = document.getElementById('player-placeholder');
           if(player) {
               player.classList.add('hidden');
               if(container) container.innerHTML = '';
               window.playerCurrentUrl = null;
           }
       }
    });

    // Premiere Started Event (Client-side transition)
    document.addEventListener('premiere-started', () => {
         console.log("Premiere started! Initializing player...");
         
         // 1. Force update to detect the now-visible inline player placeholder
         updatePlayerState(); 
         
         // 2. Wait a tick for DOM injection then Play
         setTimeout(() => {
             const container = document.getElementById('player-placeholder');
             if(container) {
                 const audio = container.querySelector('audio') as HTMLAudioElement;
                 if(audio) {
                     audio.play().catch(e => console.error("Premiere transition play failed", e));
                 }
             }
         }, 500);
    });
</script>

</script>
