---
// src/components/MiniPlayer.astro
// Persisted player component that listens for 'play-episode' events
// Now with PROFESSIONAL UI Upgrade
import FloatingBar from './player/FloatingBar.astro';
import ImmersiveView from './player/ImmersiveView.astro';
import './player/SharedPlayerStyles.css';
---

<!-- Template for the Custom Player (Cloned by JS) -->
<template id="custom-player-template">
  <div class="custom-audio-player">
      <div class="player-card" id="customPlayerCard">
         <!-- Dynamic ambient glow behind -->
         <div class="player-bg-glow" id="playerBgGlow"></div>

         <div class="player-grid">
            <!-- TOP: Metadata (Title Row) -->
            <div class="track-details">
                <h2 class="track-title" id="playerTitle">Título del Episodio</h2>
                <p class="track-artist" id="playerAuthor">Veredillas FM</p>
            </div>

            <!-- LEFT: Artwork -->
            <div class="player-artwork">
                <div class="artwork-wrapper">
                    <img src="" alt="" class="player-cover-img" id="playerCoverImg" />
                    <div class="artwork-placeholder hidden" id="playerCoverPlaceholder">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle></svg>
                    </div>
                </div>
            </div>

            <!-- CENTER: Body -->
            <div class="player-body">
                <div class="mini-visualizer">
                    <canvas id="audioVisualizer" width="300" height="64"></canvas>
                </div>

                <div class="player-controls-container">
                    <!-- Progress Bar -->
                     <div class="player-progress">
                        <span class="time-text" id="currentTime">00:00</span>
                        <div class="seek-slider-wrapper" id="seekWrapper">
                            <div class="seek-track-bg">
                                <div class="seek-track-fill" id="seekFill"></div>
                            </div>
                            <!-- Actual input for dragging -->
                            <input type="range" class="u-hidden-range" id="seekBar" value="0" step="0.1" />
                        </div>
                        <span class="time-text" id="totalTime">00:00</span>
                     </div>
                    
                    <!-- Main Buttons -->
                    <div class="item-controls">
                        <button class="btn-ctrl secondary-hide" id="backwardBtn" aria-label="Retroceder 15s">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 17l-5-5 5-5M18 17l-5-5 5-5"/></svg>
                        </button>
                        
                        <button class="btn-ctrl primary-play" id="playPauseBtn" aria-label="Reproducir/Pausar">
                            <svg id="iconPlay" class="icon-play" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
                            <svg id="iconPause" class="hidden" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
                            <svg id="iconLoading" class="hidden spinner" viewBox="0 0 50 50"><circle class="path" cx="25" cy="25" r="20" fill="none" stroke-width="5"></circle></svg>
                        </button>
                        
                        <button class="btn-ctrl secondary-hide" id="forwardBtn" aria-label="Avanzar 15s">
                             <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 17l5-5-5-5M6 17l5-5-5-5"/></svg>
                        </button>
                    </div>
                </div>
            </div>

            <!-- RIGHT: Extras -->
            <div class="player-extras">
                <button class="speed-toggle" id="speedBtn" title="Velocidad">1x</button>
                <div class="volume-area">
                    <button class="btn-ctrl" style="padding:4px; pointer-events:none;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
                    </button>
                    <input type="range" class="volume-slider" id="volumeBar" min="0" max="1" step="0.05" value="1" />
                </div>
                <!-- Maximizar Button -->
                <button class="btn-ctrl" id="maximizeBtn" aria-label="Pantalla completa">
                     <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7"/></svg>
                </button>
            </div>
         </div>
      </div>
      <!-- Core Audio Element -->
      <audio id="audioElement" preload="metadata" crossorigin="anonymous"></audio>
  </div>
</template>


<!-- Mini Player (Floating) Layout Components -->
<FloatingBar />
<ImmersiveView />

<!-- Controller Logic -->
<script>
    import { FastAverageColor } from 'fast-average-color';
    // @ts-ignore

    declare global {
        interface Window {
            hasGlobalPlayerListener: boolean;
            playerCurrentUrl: string | null;
            playerMeta: { title: string, image: string, author: string } | null;
            playerSlug: string | null;
            visualizerInterval: number;
            YT: any;
            onYouTubeIframeAPIReady: () => void;
            playerResizeObserver: ResizeObserver | null;
        }
    }

    if (!window.playerCurrentUrl) {
         window.playerCurrentUrl = null;
         window.playerMeta = null;
         window.playerSlug = null;
    }
        
    if (!window.playerCurrentUrl) {
         window.playerCurrentUrl = null;
         window.playerMeta = null;
         window.playerSlug = null;
    }
        
    const fac = new FastAverageColor();

    // Shared AudioContext to prevent "Max AudioContexts" error
    let globalAudioCtx: AudioContext | null = null;

    // ---- Ambient Mode Logic ----
    const updateAmbientTheme = async (imageUrl: string) => {
        try {
            const color = await fac.getColorAsync(imageUrl);
            // Update global vars for immersive
            document.documentElement.style.setProperty('--color-primary-glow', color.rgba);
            
            // Also update the local inline player glow if present
            const localGlow = document.getElementById('playerBgGlow');
            if(localGlow) {
                // Use a mix for better visual
                localGlow.style.background = `radial-gradient(circle at center, ${color.rgba}, transparent 70%)`;
            }

            // Update immersive glow
            const glow = document.querySelector('.background-glow') as HTMLElement;
            if (glow) {
                glow.style.background = `radial-gradient(circle at center, ${color.rgba}, transparent 70%)`;
            }
        } catch (e) {
            console.log("Ambient color check failed", e);
        }
    };

    // ---- SHARED SYNC FUNCTIONS ----

    const syncListeningTime = async (seconds: number) => {
        if (seconds <= 0.1) return; // Ignore neg or tiny
        try {
            // Fire and forget, don't await blocking UI
            fetch('/api/user/stats', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ increment: seconds })
            });
        } catch(e) {
            console.error("Stats sync error", e);
        }
    };

    // SYNC PLAYBACK HISTORY
    const syncPlaybackHistory = async (slug: string, currentTime: number, duration: number, completed: boolean = false) => {
        if(!slug) return;
        
        try {
            fetch('/api/history/update', {
                method: 'POST',
                credentials: 'include', // Ensure cookies are sent (localhost/cors safety)
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    episodeSlug: slug,
                    progress: currentTime,
                    duration: isFinite(duration) ? duration : 0,
                    completed
                })
            });
        } catch(e) {
            console.error("History sync error", e);
        }
    };

    const setupCustomPlayer = (container: HTMLElement, url: string, title: string, cover: string, author: string, transcription: any[] | null = null, startTime: number = 0, isPremiere: boolean = false, premiereDate: number = 0) => {
             // 1. CLONE TEMPLATE
             container.innerHTML = '';
             const template = document.getElementById('custom-player-template') as HTMLTemplateElement;
             if (!template) {
                 console.error("Player Template not found!");
                 return;
             }
             
             const clone = template.content.cloneNode(true) as DocumentFragment;
             container.appendChild(clone);
             
             // 2. Populate Data
             const audioElement = container.querySelector('#audioElement') as HTMLAudioElement;
             audioElement.src = url;
             
             if (startTime > 0) {
                 audioElement.currentTime = startTime;
             }

             // Metadata
             const titleEl = container.querySelector('#playerTitle');
             const authorEl = container.querySelector('#playerAuthor');
             const imgEl = container.querySelector('#playerCoverImg') as HTMLImageElement;
             const placeholderEl = container.querySelector('#playerCoverPlaceholder');
             
             if(titleEl) titleEl.textContent = title;
             if(authorEl) authorEl.textContent = author;
             
             if (cover) {
                 if(imgEl) {
                     imgEl.src = cover;
                     imgEl.classList.remove('hidden');
                 }
                 if(placeholderEl) placeholderEl.classList.add('hidden');
             } else {
                 if(imgEl) imgEl.classList.add('hidden');
                 if(placeholderEl) placeholderEl.classList.remove('hidden');
             }

             // 3. Attach Logic
             const playBtn = container.querySelector('#playPauseBtn') as HTMLElement;
             const backBtn = container.querySelector('#backwardBtn') as HTMLElement;
             const fwdBtn = container.querySelector('#forwardBtn') as HTMLElement;
             const seekBar = container.querySelector('#seekBar') as HTMLInputElement;
             const seekFill = container.querySelector('#seekFill') as HTMLElement;
             
             const volumeBar = container.querySelector('#volumeBar') as HTMLInputElement;
             const speedBtn = container.querySelector('#speedBtn') as HTMLElement;
             
             const currTimeEl = container.querySelector('#currentTime');
             const totTimeEl = container.querySelector('#totalTime');

             const iconPlay = container.querySelector('#iconPlay');
             const iconPause = container.querySelector('#iconPause');
             const iconLoading = container.querySelector('#iconLoading');
             
             const speeds = [1, 1.25, 1.5, 2, 0.75];
             let speedIdx = 0;

             // --- PREMIERE RESTRICTION HELPER ---
             const getMaxSeekTime = () => {
                 if (!isPremiere || !premiereDate) return Infinity;
                 const now = Date.now();
                 // Seconds since premiere started
                 return (now - premiereDate) / 1000;
             };

             // State updates
             const updateIcons = () => {
                 if(iconLoading && !iconLoading.classList.contains('hidden')) return;
                 if(audioElement.paused) {
                     iconPlay?.classList.remove('hidden');
                     iconPause?.classList.add('hidden');
                 } else {
                     iconPlay?.classList.add('hidden');
                     iconPause?.classList.remove('hidden');
                 }
             };

             const formatTime = (s: number) => {
                 const m = Math.floor(s / 60);
                 const sec = Math.floor(s % 60);
                 return `${m}:${sec < 10 ? '0'+sec : sec}`;
             };

             // Listeners
             playBtn.onclick = () => {
                 if(audioElement.paused) audioElement.play();
                 else audioElement.pause();
             };
             
             backBtn.onclick = () => audioElement.currentTime = Math.max(0, audioElement.currentTime - 15);
             
             fwdBtn.onclick = () => {
                 const max = getMaxSeekTime();
                 const current = audioElement.currentTime;
                 const target = current + 15;
                 
                 // Limit forward seek if premiere
                 if (target > max) {
                     // Can't go future
                     return; 
                 }
                 audioElement.currentTime = Math.min(audioElement.duration, target);
             };
             
             // Seek Bar Logic
             const updateSeekUI = () => {
                 const percent = (audioElement.currentTime / audioElement.duration) * 100;
                 if(!isNaN(percent) && seekFill) seekFill.style.width = `${percent}%`;
                 if(currTimeEl) currTimeEl.textContent = formatTime(audioElement.currentTime);
                 
                 // Visual indication of "Live" limit?
                 // Could limit the slider width visually, but `max` attribute on range input is better
                 // but range input is 0-duration. 
             };

             seekBar.oninput = () => {
                 let val = parseFloat(seekBar.value);
                 
                 // RESTRICTION CHECK
                 const max = getMaxSeekTime();
                 if (val > max) {
                     val = max;
                 }
                 
                 audioElement.currentTime = val;
                 updateSeekUI();
             }
             
             // --- AUTO-PLAY FOR PREMIERE ---
             if (isPremiere) {
                 // Try to play immediately
                 // Note: Browsers might block if no interaction, but since user likely clicked "Enter" or we reloaded, 
                 // we might need interaction. On reload? tough.
                 // But most "Live" pages attempt it.
                 // We can mute initially? No, podcast.
                 // Let's try.
                 audioElement.play().catch(e => {
                     console.log("Premiere auto-play blocked", e);
                     // Show a big "Play" overlay?
                     // For now, rely on user clicking global play.
                 });
             }
             
             let lastTrackedTime = audioElement.currentTime;
             let sessionAccumulator = 0;
             const SESSION_SYNC_THRESHOLD = 10; 

// Moved to top level


              const updateSeek = () => {
                   const current = audioElement.currentTime;
                   
                   // Tracking Logic
                   const delta = current - lastTrackedTime;
                   // Only count if playing normal speed (approx) and not seeking (large jumps)
                   if (delta > 0 && delta < 5 && !audioElement.paused) {
                       sessionAccumulator += delta;
                       if(sessionAccumulator >= SESSION_SYNC_THRESHOLD) {
                           syncListeningTime(sessionAccumulator);
                           // Sync history every 10s as well
                           if(window.playerSlug) syncPlaybackHistory(window.playerSlug, current, audioElement.duration);
                           sessionAccumulator = 0;
                       }
                   }
                   lastTrackedTime = current;
                   
                   if(document.activeElement !== seekBar) {
                       seekBar.value = current.toString();
                       updateSeekUI();
                   }
                   
                   // Dispatch Global Event for Widgets
                   document.dispatchEvent(new CustomEvent('veredillas:audio-timeupdate', {
                       detail: { currentTime: current, duration: audioElement.duration }
                   }));
              };

             volumeBar.oninput = () => {
                 audioElement.volume = parseFloat(volumeBar.value);
             }
             
             speedBtn.onclick = () => {
                 speedIdx = (speedIdx + 1) % speeds.length;
                 const s = speeds[speedIdx];
                 audioElement.playbackRate = s;
                 speedBtn.innerText = `${s}x`;
                 speedBtn.innerText = `${s}x`;
             }



             // Maximize
             const maxBtn = container.querySelector('#maximizeBtn') as HTMLElement;
             if(maxBtn) {
                 maxBtn.onclick = () => {
                     const immersive = document.getElementById('immersive-player');
                     if (immersive) immersive.classList.remove('hidden');
                 };
             }

             // Audio events
             audioElement.ontimeupdate = updateSeek;
             
             audioElement.onloadedmetadata = () => {
                 seekBar.max = audioElement.duration.toString();
                 if(totTimeEl) totTimeEl.textContent = formatTime(audioElement.duration);
                 iconLoading?.classList.add('hidden');
                 updateIcons();
             };
             
             audioElement.onwaiting = () => {
                 iconPlay?.classList.add('hidden');
                 iconPause?.classList.add('hidden');
                 iconLoading?.classList.remove('hidden');
             };
             
             audioElement.onplaying = () => {
                 iconLoading?.classList.add('hidden');
                 updateIcons();
                 initVisualizer(); 
             };
             
             audioElement.onplay = () => {
                 lastTrackedTime = audioElement.currentTime; // Reset tracking base
                 updateIcons();
             };
             audioElement.onpause = () => {
                 updateIcons();
                 // Flush pending time
                 if(sessionAccumulator > 0.5) {
                     syncListeningTime(sessionAccumulator);
                     sessionAccumulator = 0;
                 }
                 // Flush history on pause
                 if(window.playerSlug) syncPlaybackHistory(window.playerSlug, audioElement.currentTime, audioElement.duration);
             };
             
             // Error Handling 
             audioElement.onerror = (e) => {
                 const error = audioElement.error;
                 if (error && (error.code === MediaError.MEDIA_ERR_NETWORK || error.code === MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED)) {
                     if (audioElement.hasAttribute("crossorigin")) {
                         audioElement.removeAttribute("crossorigin");
                         audioElement.load();
                         // NO AUTOPLAY ON ERROR RECOVERY
                     }
                 }
             };

             audioElement.onended = () => {
                 if(window.playerSlug) syncPlaybackHistory(window.playerSlug, audioElement.duration, audioElement.duration, true);
             };
             
             // Visualizer & Voice Boost (Always Active)
             let analyser: AnalyserNode;
             let source: MediaElementAudioSourceNode;
             let compressor: DynamicsCompressorNode;
             let gainNode: GainNode;
             let canvas = container.querySelector('#audioVisualizer') as HTMLCanvasElement;
             
             const initVisualizer = () => {
                 if (!audioElement.crossOrigin) return; 

                 // Use global context or create one
                 if(!globalAudioCtx) {
                      const AudioContext = window.AudioContext || (window as any).webkitAudioContext;
                      globalAudioCtx = new AudioContext();
                 }

                 if (globalAudioCtx.state === 'suspended') {
                     globalAudioCtx.resume();
                 }

                 if (!analyser) {
                      try {
                          source = globalAudioCtx.createMediaElementSource(audioElement);
                          compressor = globalAudioCtx.createDynamicsCompressor();
                          gainNode = globalAudioCtx.createGain();
                          analyser = globalAudioCtx.createAnalyser();

                          analyser.fftSize = 512; // Higher resolution for better bass definition
                          analyser.smoothingTimeConstant = 0.85; // Smoother fallback
                          
                          // Graph: Source -> Compressor -> Gain -> Analyser -> Destination
                          source.connect(compressor);
                          compressor.connect(gainNode);
                          gainNode.connect(analyser); 
                          analyser.connect(globalAudioCtx.destination);
                          
                          // Convert to Always-On Voice Boost (Radio Processing)
                          compressor.threshold.value = -24;
                          compressor.knee.value = 30;
                          compressor.ratio.value = 12;
                          compressor.attack.value = 0.003;
                          compressor.release.value = 0.25;
                          
                          // Makeup Gain +6dB hardcoded
                          gainNode.gain.value = 2.0; 
                          
                          draw();
                      } catch(e) {
                          console.log("Audio Context Error (CORS?):", e);
                      }
                 }
             };
             
             const draw = () => {
                 if(!canvas || !analyser) return;
                 const ctx = canvas.getContext('2d');
                 if(!ctx) return;
                 
                 const bufferLength = analyser.frequencyBinCount;
                 const dataArray = new Uint8Array(bufferLength);
                 
                 const renderFrame = () => {
                     if(audioElement.paused) return; 
                     requestAnimationFrame(renderFrame);
                     
                     ctx.clearRect(0,0, canvas.width, canvas.height);
                     
                     analyser.getByteFrequencyData(dataArray);

                     // Dynamic Color based on Ambient Theme
                     const glowColor = getComputedStyle(document.documentElement).getPropertyValue('--color-primary-glow').trim() || 'rgba(139, 92, 246, 0.8)';
                     // If the glow is too transparent, make it more solid for the bars
                     ctx.fillStyle = glowColor.replace('0.2', '0.8').replace('0.5', '0.9');

                     // Settings for bars
                     const barCount = 40; 
                     // Focus on the sub-50% frequencies (most musical content)
                     const usefulBinCount = Math.floor(bufferLength * 0.6); 
                     const step = usefulBinCount / barCount;
                     
                     const barWidth = canvas.width / barCount;
                     const gap = 2;
                     
                     for(let i=0; i<barCount; i++) {
                         // Logarithmic-ish or simple averaging
                         const start = Math.floor(i * step);
                         const end = Math.floor((i + 1) * step);
                         let sum = 0;
                         let count = 0;
                         for(let j=start; j<end; j++) {
                             sum += dataArray[j];
                             count++;
                         }
                         const val = count > 0 ? sum / count : 0;
                         
                         // Non-linear height for punchier look
                         // (val / 255)^1.2 allows peaks to stand out more vs noise
                         const percent = Math.pow(val / 255, 1.2); 
                         
                         let h = percent * canvas.height;
                         if (h < 2 && val > 0) h = 2; // Min height if sound exists
                         
                         const x = i * barWidth;
                         const y = canvas.height - h;
                         
                         // Rounded Top Bars
                         if(h > 0) {
                             ctx.beginPath();
                             if(ctx.roundRect) {
                                 ctx.roundRect(x + gap/2, y, barWidth - gap, h, [4, 4, 0, 0]);
                             } else {
                                 ctx.rect(x + gap/2, y, barWidth - gap, h);
                             }
                             ctx.fill();
                         }
                     }
                      
                     // Also handle Immersive Visualizer (Global)
                     // Re-use logic for immersive if open
                     const immCanvas = document.getElementById('audio-visualizer') as HTMLCanvasElement;
                     const immersiveEl = document.getElementById('immersive-player');
                     // Check if visible (not hidden)
                     if(immCanvas && immersiveEl && !immersiveEl.classList.contains('hidden')) {
                         // Basic mirror of the logic for the big player
                         // ideally this should be a separate drawer but let's do a simple pass
                         const immCtx = immCanvas.getContext('2d');
                         if(immCtx) {
                             immCtx.clearRect(0,0, immCanvas.width, immCanvas.height);
                             immCtx.fillStyle = ctx.fillStyle; // Same color
                             
                             // Adjust dimensions if needed (canvas might differ in size from CSS)
                             // Usually we should relying on width/height attributes or resize observer, 
                             // but assuming it's substantial (e.g. 300px default or sized by CSS w/ resize)
                             // For now assuming the canvas element generic sizing.
                             // Ideally we should set immCanvas.width = immCanvas.offsetWidth... but let's skip expensive resize in loop.
                             
                             const immBarWidth = immCanvas.width / barCount;
                             
                             for(let i=0; i<barCount; i++) {
                                 const start = Math.floor(i * step);
                                 const end = Math.floor((i + 1) * step);
                                 let sum = 0, count=0;
                                 for(let j=start; j<end; j++) { sum+=dataArray[j]; count++; }
                                 const val = count>0 ? sum/count : 0;
                                 const percent = Math.pow(val/255, 1.2);
                                 const h = percent * immCanvas.height * 0.6; // Scale down a bit?
                                 
                                 const x = i * immBarWidth;
                                 // Let's do Center for immersive
                                 const cy = immCanvas.height / 2;
                                 
                                 immCtx.beginPath();
                                 if(immCtx.roundRect) immCtx.roundRect(x+gap, cy - h/2, immBarWidth-gap*2, h, [4]);
                                 else immCtx.rect(x+gap, cy - h/2, immBarWidth-gap*2, h);
                                 immCtx.fill();
                             }
                         }
                     }
                 };
                 renderFrame();
             };

             // Initial Ambient
             if(cover) updateAmbientTheme(cover);

             // --- Initialize Immersive Sync (Metadata) ---
             const immTitle = document.getElementById('immersive-title');
             const immAuthor = document.getElementById('immersive-author');
             const immCover = document.getElementById('immersive-cover') as HTMLImageElement;
             
             if(immTitle) immTitle.innerText = title;
             if(immAuthor) immAuthor.innerText = author;
             if(immCover) immCover.src = cover || '/logo.png';
             
             // Setup Seek Sync with Immersive
             setupImmersiveSync(audioElement, {
                title, author, cover, transcription
             });
    };

    // Helper for Immersive Sync (Metadata & Transcription)
    const setupImmersiveSync = (audio: HTMLAudioElement, meta: any) => {
             const immPlayBtn = document.getElementById('imm-play-btn');
             const immIconPlay = document.getElementById('imm-icon-play');
             const immIconPause = document.getElementById('imm-icon-pause');
             const immSeekBar = document.getElementById('imm-seek-bar') as HTMLInputElement;
             const immCurrentTime = document.getElementById('imm-current-time');
             const immDuration = document.getElementById('imm-duration');
             const immBack = document.getElementById('imm-back-btn');
             const immFwd = document.getElementById('imm-fwd-btn');

             const collapseBtn = document.getElementById('collapse-player');
             

             
             // Collapse Player
             if (collapseBtn) {
                 collapseBtn.onclick = () => {
                     document.getElementById('immersive-player')?.classList.add('hidden');
                 };
             }

             if(immPlayBtn) {
                 immPlayBtn.onclick = () => {
                     if(audio.paused) audio.play();
                     else audio.pause();
                 };
             }
             if(immBack) immBack.onclick = () => audio.currentTime = Math.max(0, audio.currentTime - 15);
             if(immFwd) immFwd.onclick = () => audio.currentTime = Math.min(audio.duration, audio.currentTime + 15);
             
             if(immSeekBar) {
                 immSeekBar.oninput = () => audio.currentTime = parseFloat(immSeekBar.value);
             }



             // Time Update Sync
             const onTimeUpdate = () => {
                 if(immSeekBar && document.activeElement !== immSeekBar) immSeekBar.value = audio.currentTime.toString();
                 if(immCurrentTime) {
                      const m = Math.floor(audio.currentTime / 60);
                      const s = Math.floor(audio.currentTime % 60);
                      immCurrentTime.textContent = `${m}:${s < 10 ? '0'+s : s}`;
                 }
                 

             };
             
             audio.addEventListener('timeupdate', onTimeUpdate);
             
             audio.addEventListener('play', () => {
                  if(immIconPlay) immIconPlay.classList.add('hidden');
                  if(immIconPause) immIconPause.classList.remove('hidden');
             });
             audio.addEventListener('pause', () => {
                  if(immIconPlay) immIconPlay.classList.remove('hidden');
                  if(immIconPause) immIconPause.classList.add('hidden');
             });
             
             audio.addEventListener('loadedmetadata', () => {
                 if(immSeekBar) immSeekBar.max = audio.duration.toString();
                 if(immDuration) {
                      const m = Math.floor(audio.duration / 60);
                      const s = Math.floor(audio.duration % 60);
                      immDuration.textContent = `${m}:${s < 10 ? '0'+s : s}`;
                 }
             });
    };

    // Global State Update
    const updatePlayerState = () => {
            const player = document.getElementById('mini-player');
            const placeholder = document.getElementById('episode-player-placeholder');
            const container = document.getElementById('player-placeholder');
            
            if (!player || !container) return;

            if (placeholder) {
                // Determine if we should render yet (might be hidden by countdown)
                const parentWrapper = document.getElementById('premiere-player-wrapper');
                const isHiddenPremiere = parentWrapper && (window.getComputedStyle(parentWrapper).display === 'none' || parentWrapper.classList.contains('hidden'));
                
                if (isHiddenPremiere) {
                    // Don't render inline player yet if it is waiting for premiere
                    // Ensure player is hidden so it doesn't stick around from previous state or default
                    player.classList.add('hidden');
                    return; 
                }

                // INLINE MODE
                const spotifyUrl = placeholder.getAttribute('data-spotify-url');
                const audioUrl = placeholder.getAttribute('data-audio-url');
                const url = spotifyUrl || audioUrl;
                const title = placeholder.getAttribute('data-title');
                const image = placeholder.getAttribute('data-image');
                const author = placeholder.getAttribute('data-author');
                const slug = placeholder.getAttribute('data-slug');

                if (title) {
                    window.playerMeta = { title, image: image || '/logo.png', author: author || 'Veredillas FM' };
                    if(slug) window.playerSlug = slug;
                }

                // Conflict Check
                if (window.playerCurrentUrl && url && window.playerCurrentUrl !== url) {
                    // Conflict -> Show Floating
                    if (container.hasChildNodes()) {
                        player.classList.remove('inline', 'hidden');
                        player.classList.add('floating', 'visible');
                        
                        // Apply floating specific styles just in case JS needs to force it, though CSS handles .floating
                        document.body.style.paddingBottom = '100px';
                    }
                    
                    // Render "Currently Playing different ep" prompt in placeholder
                    if (!placeholder.hasAttribute('data-rendered-prompt')) {
                         placeholder.setAttribute('data-rendered-prompt', 'true');
                         placeholder.innerHTML = `
                            <div class="glass-panel" style="width:100%; height:160px; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:16px; border-radius:12px;">
                                <p style="margin:0; color: #a1a1aa;">Estás escuchando otro episodio</p>
                                <button id="force-play-btn" class="btn btn-primary" style="font-size:0.9rem; padding: 6px 16px;">
                                    Reproducir este
                                </button>
                            </div>
                        `;
                        placeholder.querySelector('#force-play-btn')?.addEventListener('click', () => {
                             window.playerCurrentUrl = null; 
                             container.innerHTML = ''; // Reset floating player
                             updatePlayerState(); // Re-run to trigger inline setup
                        });
                    }
                    return;
                }

                // Setup Inline
                if (url && window.playerCurrentUrl !== url) {
                    window.playerCurrentUrl = url;
                    
                    const videoUrl = placeholder.getAttribute('data-video-url');
                    
                    // Clear container
                    container.innerHTML = '';
                    // Container needs relative positioning for overlays
                    container.style.position = 'relative'; 

                    const renderVideoMode = () => {
                        container.innerHTML = '';
                        
                        const isYouTube = videoUrl && (videoUrl.includes('youtube.com') || videoUrl.includes('youtu.be'));

                        if (isYouTube) {
                             // --- YOUTUBE PLAYER WITH CUSTOM SKIN ---
                             const wrapper = document.createElement('div');
                             wrapper.style.position = 'relative';
                             wrapper.style.width = '100%';
                             wrapper.style.height = '352px';
                             wrapper.style.borderRadius = '12px';
                             wrapper.style.overflow = 'hidden';
                             wrapper.style.background = '#000';
                             // Show controls on hover
                             wrapper.addEventListener('mouseenter', () => {
                                 const c = wrapper.querySelector('.yt-custom-controls') as HTMLElement;
                                 if(c) c.style.opacity = '1';
                             });
                             wrapper.addEventListener('mouseleave', () => {
                                 const c = wrapper.querySelector('.yt-custom-controls') as HTMLElement;
                                 if(c) c.style.opacity = '0';
                             });
                             container.appendChild(wrapper);

                             const ytDiv = document.createElement('div');
                             ytDiv.id = 'yt-player-container';
                             wrapper.appendChild(ytDiv);

                             // Custom Controls UI
                             const controlsOverlay = document.createElement('div');
                             controlsOverlay.className = 'yt-custom-controls';
                             controlsOverlay.style.cssText = `
                                position: absolute;
                                bottom: 0; left: 0; right: 0;
                                padding: 16px 20px;
                                background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
                                display: flex;
                                align-items: center;
                                gap: 12px;
                                opacity: 0;
                                transition: opacity 0.3s ease;
                                pointer-events: auto;
                             `;
                             
                             // Inner HTML for controls
                             controlsOverlay.innerHTML = `
                                <button id="yt-play-btn" style="background:none; border:none; color:white; cursor:pointer; padding:0; display:flex; align-items:center;">
                                    <svg id="yt-icon-play" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
                                    <svg id="yt-icon-pause" class="hidden" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
                                </button>
                                
                                <span id="yt-time-current" style="font-size:12px; font-variant-numeric:tabular-nums; color:#ddd; min-width:35px;">0:00</span>
                                
                                <div style="flex:1; display:flex; align-items:center; position:relative; height:16px; cursor:pointer;" id="yt-seek-track">
                                    <div style="position:absolute; top:7px; left:0; right:0; height:4px; background:rgba(255,255,255,0.3); border-radius:2px;"></div>
                                    <div id="yt-seek-fill" style="position:absolute; top:7px; left:0; width:0%; height:4px; background:var(--color-primary, #8b5cf6); border-radius:2px;"></div>
                                    <input type="range" id="yt-seek-input" min="0" max="100" step="0.1" value="0" style="
                                        position:absolute; width:100%; height:100%; opacity:0; cursor:pointer; margin:0;
                                    " />
                                </div>
                                
                                <span id="yt-time-total" style="font-size:12px; font-variant-numeric:tabular-nums; color:#ddd; min-width:35px;">0:00</span>
                             `;
                             
                             wrapper.appendChild(controlsOverlay);

                             // Extract Video ID
                             let videoId = '';
                             try {
                                 const vUrl = new URL(videoUrl!);
                                 if(vUrl.hostname.includes('youtu.be')) {
                                     videoId = vUrl.pathname.slice(1);
                                 } else if (vUrl.pathname.includes('/embed/')) {
                                     videoId = vUrl.pathname.split('/embed/')[1].split('?')[0];
                                 } else {
                                     const params = new URLSearchParams(vUrl.search);
                                     videoId = params.get('v') || '';
                                 }
                             } catch(e) { console.error("Error parsing YT URL", e); }

                             if (!videoId) {
                                 container.innerHTML = '<div style="color:white; padding:20px;">Error: Invalid YouTube URL</div>';
                                 return;
                             }
                             
                             let ytPlayer: any = null;
                             let isDragging = false;
                             let ytTimer: NodeJS.Timeout | null = null;
                             let ytAccumulator = 0;
                             let ytLastTime = 0;

                             // Elements
                             const btnPlay = controlsOverlay.querySelector('#yt-play-btn') as HTMLElement;
                             const iconPlay = controlsOverlay.querySelector('#yt-icon-play') as HTMLElement;
                             const iconPause = controlsOverlay.querySelector('#yt-icon-pause') as HTMLElement;
                             const seekInput = controlsOverlay.querySelector('#yt-seek-input') as HTMLInputElement;
                             const seekFill = controlsOverlay.querySelector('#yt-seek-fill') as HTMLElement;
                             const timeCurr = controlsOverlay.querySelector('#yt-time-current') as HTMLElement;
                             const timeTotal = controlsOverlay.querySelector('#yt-time-total') as HTMLElement;
                             
                             const formatTime = (s: number) => {
                                 const m = Math.floor(s / 60);
                                 const sec = Math.floor(s % 60);
                                 return `${m}:${sec < 10 ? '0'+sec : sec}`;
                             };

                             // Helper to init player
                             const initYT = () => {
                                 const startStr = placeholder.getAttribute('data-start-time');
                                 const startTime = startStr ? Math.floor(parseFloat(startStr)) : 0;

                                 // @ts-ignore
                                 ytPlayer = new window.YT.Player('yt-player-container', {
                                     height: '352',
                                     width: '100%',
                                     videoId: videoId,
                                     playerVars: {
                                         'playsinline': 1,
                                         'autoplay': 0, 
                                         'controls': 0, // HIDE NATIVE CONTROLS
                                         'modestbranding': 1,
                                         'rel': 0,
                                         'showinfo': 0,
                                         'iv_load_policy': 3,
                                         'disablekb': 1,
                                         'fs': 0,
                                         'start': startTime
                                     },
                                     events: {
                                         'onReady': (event: any) => {
                                             if(timeTotal) timeTotal.textContent = formatTime(event.target.getDuration());
                                             if(seekInput) seekInput.max = event.target.getDuration().toString();
                                         },
                                         'onStateChange': (event: any) => {
                                             onYTStateChange(event.target);
                                         }
                                     }
                                 });
                             };
                             
                             // Controls Logic
                             btnPlay.onclick = () => {
                                 if(!ytPlayer || typeof ytPlayer.getPlayerState !== 'function') return;
                                 const state = ytPlayer.getPlayerState();
                                 if(state === 1) ytPlayer.pauseVideo();
                                 else ytPlayer.playVideo();
                             };
                             
                             seekInput.oninput = () => {
                                 isDragging = true;
                                 const val = parseFloat(seekInput.value);
                                 if(seekFill && ytPlayer) {
                                     const d = ytPlayer.getDuration();
                                     if(d > 0) seekFill.style.width = `${(val/d)*100}%`;
                                 }
                                 if(timeCurr) timeCurr.textContent = formatTime(val);
                             };
                             
                             seekInput.onchange = () => {
                                 if(ytPlayer) ytPlayer.seekTo(parseFloat(seekInput.value), true);
                                 isDragging = false;
                             };

                             const updateUI = (curr: number, duration: number) => {
                                 if(!isDragging) {
                                     seekInput.value = curr.toString();
                                     if(seekFill && duration > 0) seekFill.style.width = `${(curr/duration)*100}%`;
                                     if(timeCurr) timeCurr.textContent = formatTime(curr);
                                 }
                                 if(timeTotal && duration > 0) timeTotal.textContent = formatTime(duration);
                                 seekInput.max = duration.toString();
                             };

                             const onYTStateChange = (player: any) => {
                                 const state = player.getPlayerState();
                                 // 1 = PLAYING
                                 if (state === 1) {
                                     iconPlay.classList.add('hidden');
                                     iconPause.classList.remove('hidden');
                                     controlsOverlay.style.opacity = '1'; // Show UI briefly on play
                                     setTimeout(() => { 
                                         if(!wrapper.matches(':hover')) controlsOverlay.style.opacity = '0';
                                     }, 2000);

                                     ytLastTime = player.getCurrentTime();
                                     
                                     if (ytTimer) clearInterval(ytTimer);
                                     ytTimer = setInterval(() => {
                                         const curr = player.getCurrentTime();
                                         const dur = player.getDuration();
                                         updateUI(curr, dur);

                                         const delta = curr - ytLastTime;
                                         if (delta > 0 && delta < 5) {
                                             ytAccumulator += delta;
                                             if (ytAccumulator >= 10) {
                                                 syncListeningTime(ytAccumulator);
                                                 if (window.playerSlug) syncPlaybackHistory(window.playerSlug, curr, dur);
                                                 ytAccumulator = 0;
                                             }
                                         }
                                         ytLastTime = curr;
                                     }, 500); // 500ms for smoother UI
                                 } else {
                                     // Paused or Ended
                                     iconPlay.classList.remove('hidden');
                                     iconPause.classList.add('hidden');
                                     controlsOverlay.style.opacity = '1'; // Show UI when paused
                                     
                                     if (ytTimer) {
                                         clearInterval(ytTimer);
                                         ytTimer = null;
                                     }
                                     if (ytAccumulator > 0.5) {
                                         syncListeningTime(ytAccumulator);
                                         ytAccumulator = 0;
                                     }
                                     if (window.playerSlug && (state === 2 || state === 0)) {
                                         syncPlaybackHistory(
                                             window.playerSlug, 
                                             player.getCurrentTime(), 
                                             player.getDuration(), 
                                             state === 0
                                         );
                                     }
                                 }
                             };

                             
                             // Load API if needed
                             if (!window.YT) {
                                 const tag = document.createElement('script');
                                 tag.src = "https://www.youtube.com/iframe_api";
                                 const firstScriptTag = document.getElementsByTagName('script')[0];
                                 firstScriptTag.parentNode?.insertBefore(tag, firstScriptTag);
                                 
                                 window.onYouTubeIframeAPIReady = () => {
                                     initYT();
                                 };
                             } else {
                                 initYT();
                             }

                        } else {
                             // EXISTING IFRAME LOGIC (Generic/Spotify)
                            const iframe = document.createElement('iframe');
                            iframe.style.borderRadius = '12px';
                            iframe.src = videoUrl || '';
                            iframe.width = "100%";
                            iframe.height = "352";
                            iframe.frameBorder = "0";
                            iframe.allow = "autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture";
                            iframe.loading = "lazy";
                            iframe.style.display = 'block'; // Prevent inline-block spacing
                            
                            container.appendChild(iframe);
                        }

                        
                        // Overlay "Headphones" Button to switch back
                        const switchBtn = document.createElement('button');
                        switchBtn.className = 'media-toggle-overlay';
                        switchBtn.title = "Escuchar Audio";
                        switchBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 18v-6a9 9 0 0 1 18 0v6"></path><path d="M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z"></path></svg>`;
                        // Ensure it's absolutely positioned on top of the wrapper if wrapper exists
                        if (isYouTube) {
                            switchBtn.style.zIndex = '10'; // Above video controls
                        }
                        
                        switchBtn.onclick = () => renderAudioMode();
                        container.appendChild(switchBtn);
                        
                        // Explicitly Force Height for Video Iframe (352px)
                        // allowing transition to catch up
                        placeholder.style.height = '352px';
                        placeholder.style.minHeight = '352px';

                    };

                    const renderAudioMode = () => {
                         container.innerHTML = '';
                         
                         let contentContainer = container;
                         
                         // If we are strictly in audio mode, we might want to wrap custom player?
                         // setupCustomPlayer appends into the passed container.
                         
                         if (spotifyUrl) {
                            // Spotify Logic
                            let finalUrl = url;
                            try {
                                 const urlObj = new URL(url);
                                 if (!urlObj.pathname.includes('/embed/')) {
                                      const segments = urlObj.pathname.split('/').filter(Boolean);
                                      if (segments[0] !== 'embed') finalUrl = `${urlObj.origin}/embed${urlObj.pathname}`;
                                 }
                            } catch(e) {}
                            
                            container.innerHTML = `<iframe style="border-radius:12px" src="${finalUrl}" width="100%" height="152" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" loading="lazy"></iframe>`;
                            
                            // If Dual Mode, add overlay button on top of Spotify Iframe
                            if (videoUrl) {
                                const switchBtn = document.createElement('button');
                                switchBtn.className = 'media-toggle-overlay';
                                switchBtn.title = "Ver Video";
                                switchBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 7l-7 5 7 5V7z"></path><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg>`;
                                switchBtn.onclick = () => renderVideoMode();
                                container.appendChild(switchBtn);
                            }

                        } else if (audioUrl && title) {
                            const transcriptionStr = placeholder.getAttribute('data-transcription');
                            const startStr = placeholder.getAttribute('data-start-time');
                            const startTime = startStr ? parseFloat(startStr) : 0;
                            
                            // PREMIERE LOGIC READ
                            const isPremiere = placeholder.getAttribute('data-is-premiere') === 'true';
                            const premiereDateStr = placeholder.getAttribute('data-premiere-date');
                            const premiereDate = premiereDateStr ? new Date(premiereDateStr).getTime() : 0;
    
                            const trans = transcriptionStr ? JSON.parse(transcriptionStr) : null;
                            setupCustomPlayer(container, audioUrl, title, image || '', author || '', trans, startTime, isPremiere, premiereDate);
                            
                            // Inject Button into Custom Player Extras
                            if (videoUrl) {
                                const extras = container.querySelector('.player-extras');
                                if (extras) {
                                    const vidBtn = document.createElement('button');
                                    vidBtn.className = 'btn-ctrl video-toggle';
                                    vidBtn.title = "Ver Video";
                                    vidBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 7l-7 5 7 5V7z"></path><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg>`;
                                    vidBtn.onclick = () => renderVideoMode();
                                    
                                    // Insert before the last element (Maximize) or first?
                                    // Extras has: Speed, Volume|None, Maximize
                                    const maximizeBtn = extras.querySelector('#maximizeBtn');
                                    if(maximizeBtn) {
                                        extras.insertBefore(vidBtn, maximizeBtn);
                                    } else {
                                        extras.appendChild(vidBtn);
                                    }
                                }
                            }
                        }
                        
                        // IMMEDIATE HEIGHT RESET (Collapse gap)
                        if (spotifyUrl) {
                            placeholder.style.minHeight = '0px'; 
                            placeholder.style.height = '152px'; 
                        } else {
                            placeholder.style.minHeight = '0px';
                            placeholder.style.height = 'auto'; 
                        }
                        

                    }; // Close renderAudioMode
                    renderAudioMode();
                }


                // DOM TRANSPLANTATION STRATEGY
                // Instead of absolute positioning hacks, we literally move the player into the placeholder.
                // This ensures perfect flow and height calculation by the browser.
                
                if (player.parentNode !== placeholder) {
                    placeholder.appendChild(player);
                }

                player.classList.remove('floating', 'hidden');
                player.classList.add('inline', 'visible');
                
                // Reset Styles for Inline Flow
                player.style.position = 'relative';
                player.style.top = 'auto';
                player.style.left = 'auto';
                player.style.bottom = 'auto';
                player.style.width = '100%';
                player.style.height = 'auto';
                
                // Ensure wrapper flow
                const wrapper = player.querySelector('.player-wrapper') as HTMLElement;
                if(wrapper) {
                    wrapper.style.height = 'auto';
                    wrapper.style.minHeight = '100%';
                }
                
                // Remove specific height overrides on placeholder creates by previous logic
                placeholder.style.height = 'auto';
                placeholder.style.minHeight = '0px';

                document.body.style.paddingBottom = '0';
                
                // Initial Render (moved here to ensure it renders into the now-transplanted container if needed, though container is internal)
                // renderAudioMode(); // Removed out-of-scope call


            } else {
                // FLOATING MODE
                if (container.hasChildNodes()) {
                    player.classList.remove('inline', 'hidden');
                    player.classList.add('floating', 'visible');

                    player.style.position = 'fixed';
                    player.style.top = 'auto'; // Reset
                    player.style.bottom = '0';
                    player.style.left = '0';
                    player.style.width = '100%';
                    player.style.height = 'auto';

                    document.body.style.paddingBottom = '100px';
                } else {
                    player.classList.add('hidden');
                    document.body.style.paddingBottom = '0';
                }
            }
    };

    // Event Listeners
    window.addEventListener('resize', updatePlayerState);
    document.addEventListener('DOMContentLoaded', updatePlayerState);
    
    // Play Episode Event
    document.addEventListener('play-episode', ((e: Event) => {
         const customEvent = e as CustomEvent;
          const { url, title, image, author } = customEvent.detail;
          const slug = customEvent.detail.slug; // Passed dynamically?
          // If we played from a card that didn't pass slug, we might miss it.
          // But EpisodeCard usually navigates. 
          // If we play from Play Button on card, we need slug.
          
          const container = document.getElementById('player-placeholder');
          if(container) {
              window.playerCurrentUrl = url;
              window.playerMeta = { title, image, author };
              if(slug) window.playerSlug = slug;
              
              setupCustomPlayer(container, url, title, image, author);
             updatePlayerState();
             
             // FORCE PLAY
             const audio = container.querySelector('audio') as HTMLAudioElement;
             if(audio) {
                 audio.play().catch(e => console.error("Auto-play failed:", e));
             }
         }
    }));

    // Close Button Logic (in FloatingBar)
    document.addEventListener('click', (e) => {
       const target = e.target as HTMLElement;
       if(target.closest('#close-player')) {
           const player = document.getElementById('mini-player');
           const container = document.getElementById('player-placeholder');
           if(player) {
               player.classList.add('hidden');
               if(container) container.innerHTML = '';
               window.playerCurrentUrl = null;
           }
       }
    });

    // Premiere Started Event (Client-side transition)
    document.addEventListener('premiere-started', () => {
         console.log("Premiere started! Initializing player...");
         
         // 1. Force update to detect the now-visible inline player placeholder
         updatePlayerState(); 
         
         // 2. Wait a tick for DOM injection then Play
         setTimeout(() => {
             const container = document.getElementById('player-placeholder');
             if(container) {
                 const audio = container.querySelector('audio') as HTMLAudioElement;
                 if(audio) {
                     audio.play().catch(e => console.error("Premiere transition play failed", e));
                 }
             }
         }, 500);
    });
</script>


